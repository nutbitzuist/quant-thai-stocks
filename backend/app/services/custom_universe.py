"""
Custom Universe Manager
Allows users to create and manage their own stock universes
With user ownership and soft delete support, backed by PostgreSQL.
"""

from typing import Dict, List, Optional, Any
from datetime import datetime
import re
import logging
from sqlalchemy.ext.asyncio import AsyncSession
from sqlalchemy import select, update
from sqlalchemy.orm import selectinload

from app.database.models import CustomUniverse as DBUniverse
from app.database import get_db

logger = logging.getLogger(__name__)

# System user ID for built-in example universes
SYSTEM_USER_ID = "__system__"


class CustomUniverseManager:
    """
    Manages custom user-defined universes with ownership
    Uses AsyncSession for database persistence
    """
    
    def __init__(self):
        # We no longer load examples in __init__ as it requires async db access
        # Examples should be loaded via a separate async init method or migration script
        pass
    
    def _generate_id(self, name: str) -> str:
        """Generate a unique-ish ID (DB handles uniqueness effectively via UUID, but keeping for backward compat if needed)"""
        return re.sub(r'[^a-z0-9]+', '_', name.lower()).strip('_')
    
    def _normalize_ticker(self, ticker: str) -> str:
        """Normalize ticker format"""
        ticker = ticker.strip().upper()
        if ticker.endswith('.US'):
            ticker = ticker[:-3]
        return ticker

    async def create_universe(
        self,
        db: AsyncSession,
        name: str,
        description: str,
        tickers: List[str],
        market: str = "Mixed",
        user_id: str = ""
    ) -> Dict:
        """Create a new custom universe for a user"""
        if not user_id:
            raise ValueError("user_id is required to create a universe")
        
        now = datetime.now()
        
        # Normalize tickers
        normalized_tickers = [self._normalize_ticker(t) for t in tickers if t.strip()]
        unique_tickers = list(dict.fromkeys(normalized_tickers)) # Remove dups, keep order
        
        db_universe = DBUniverse(
            # ID is auto-generated by model default
            name=name,
            description=description,
            symbols=unique_tickers,  # mapped to 'tickers' in logic, 'symbols' in DB
            market=market,
            created_at=now,
            updated_at=now,
            user_id=user_id,
            is_public=False
        )
        
        db.add(db_universe)
        await db.commit()
        await db.refresh(db_universe)
        
        return self._to_dict(db_universe)

    async def update_universe(
        self,
        db: AsyncSession,
        universe_id: str,
        user_id: str,
        name: Optional[str] = None,
        description: Optional[str] = None,
        tickers: Optional[List[str]] = None,
        market: Optional[str] = None
    ) -> Optional[Dict]:
        """Update an existing custom universe (owner only)"""
        
        # Fetch universe
        query = select(DBUniverse).where(DBUniverse.id == universe_id)
        result = await db.execute(query)
        universe = result.scalar_one_or_none()
        
        if not universe:
            return None
            
        # Check ownership
        if universe.user_id != user_id and universe.user_id != SYSTEM_USER_ID:
            logger.warning(f"User {user_id} attempted to update universe {universe_id} owned by {universe.user_id}")
            return None
        
        # System universes are read-only via API
        if universe.user_id == SYSTEM_USER_ID:
             logger.warning(f"User {user_id} attempted to update system universe {universe_id}")
             return None
             
        # Check soft delete
        if universe.deleted_at is not None:
            return None
            
        if name is not None:
            universe.name = name
        if description is not None:
            universe.description = description
        if tickers is not None:
             normalized = [self._normalize_ticker(t) for t in tickers if t.strip()]
             universe.symbols = list(dict.fromkeys(normalized))
        if market is not None:
            universe.market = market
            
        universe.updated_at = datetime.now()
        
        await db.commit()
        await db.refresh(universe)
        return self._to_dict(universe)

    async def delete_universe(self, db: AsyncSession, universe_id: str, user_id: str, soft: bool = True) -> bool:
        """Delete a custom universe (owner only)"""
        query = select(DBUniverse).where(DBUniverse.id == universe_id)
        result = await db.execute(query)
        universe = result.scalar_one_or_none()
        
        if not universe:
            return False
            
        if universe.user_id != user_id:
             logger.warning(f"User {user_id} attempted to delete universe {universe_id} owned by {universe.user_id}")
             return False
             
        if universe.user_id == SYSTEM_USER_ID:
            return False
            
        if soft:
            universe.deleted_at = datetime.now()
        else:
            await db.delete(universe)
            
        await db.commit()
        return True

    async def get_universe(self, db: AsyncSession, universe_id: str, user_id: Optional[str] = None) -> Optional[Dict]:
        """Get a specific custom universe"""
        query = select(DBUniverse).where(DBUniverse.id == universe_id)
        result = await db.execute(query)
        universe = result.scalar_one_or_none()
        
        if not universe:
            return None
            
        if universe.deleted_at is not None:
            return None
            
        # Check access: System universes are public, otherwise must own it
        if universe.user_id != SYSTEM_USER_ID:
            if not user_id or universe.user_id != user_id:
                return None
                
        return self._to_dict(universe)

    async def get_all_universes(self, db: AsyncSession, user_id: Optional[str] = None) -> List[Dict]:
        """Get all custom universes visible to a user (System + User's own)"""
        
        # Build query: (is_system OR owned_by_user) AND not_deleted
        # Since we want to optimize, we can just do two simple filters or one OR
        
        # Get System Universes
        system_query = select(DBUniverse).where(
            DBUniverse.user_id == SYSTEM_USER_ID,
            DBUniverse.deleted_at.is_(None)
        )
        system_result = await db.execute(system_query)
        system_universes = system_result.scalars().all()
        
        results = [self._to_dict(u) for u in system_universes]
        
        # Get User Universes if user_id provided
        if user_id:
            user_query = select(DBUniverse).where(
                DBUniverse.user_id == user_id,
                DBUniverse.deleted_at.is_(None)
            )
            user_result = await db.execute(user_query)
            user_universes = user_result.scalars().all()
            results.extend([self._to_dict(u) for u in user_universes])
            
        return results

    async def get_tickers(self, db: AsyncSession, universe_id: str, user_id: Optional[str] = None) -> List[str]:
        """Get tickers for a custom universe"""
        universe = await self.get_universe(db, universe_id, user_id)
        return universe['tickers'] if universe else []

    def parse_ticker_input(self, input_text: str) -> List[str]:
         """Parse ticker input (flexible format) - Pure logic, no DB needed"""
         normalized = input_text.replace('\n', ',').replace('\t', ',').replace(';', ',')
         tickers = []
         for part in normalized.split(','):
             for ticker in part.split():
                 cleaned = ticker.strip().upper()
                 if cleaned and len(cleaned) <= 20:
                     tickers.append(cleaned)
         return tickers

    async def import_from_text(
        self,
        db: AsyncSession,
        name: str,
        description: str,
        ticker_text: str,
        market: str = "Mixed",
        user_id: str = ""
    ) -> Dict:
        """Create universe from text input"""
        tickers = self.parse_ticker_input(ticker_text)
        return await self.create_universe(db, name, description, tickers, market, user_id)

    def _to_dict(self, db_obj: DBUniverse) -> Dict:
        """Convert DB model to dictionary matching API expected format"""
        return {
            "id": db_obj.id,
            "name": db_obj.name,
            "description": db_obj.description,
            "tickers": db_obj.symbols,
            "market": db_obj.market,
            "created_at": db_obj.created_at.isoformat() if db_obj.created_at else None,
            "updated_at": db_obj.updated_at.isoformat() if db_obj.updated_at else None,
            "user_id": db_obj.user_id,
            "is_system": db_obj.user_id == SYSTEM_USER_ID,
            "is_deleted": db_obj.deleted_at is not None,
            "count": len(db_obj.symbols) if db_obj.symbols else 0
        }


# Singleton
_custom_universe_manager = None

def get_custom_universe_manager() -> CustomUniverseManager:
    global _custom_universe_manager
    if _custom_universe_manager is None:
        _custom_universe_manager = CustomUniverseManager()
    return _custom_universe_manager
